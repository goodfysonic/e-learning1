{"ast":null,"code":"import { apiTenantUrl, storageKeys } from '@constants';\nimport apiConfig from '@constants/apiConfig';\nimport { getData, removeItem } from '@utils/localStorage';\nimport axios from 'axios';\nimport { getCacheAccessToken, getCacheUserEmail, getCacheRefreshToken, removeCacheToken, setCacheToken } from './userService';\nimport jwtDecode from 'jwt-decode';\n// Handle refresh token\nconst axiosInstance = axios.create();\nlet isRefreshing = false;\nlet subscribers = [];\nconst onRefreshed = newAccessToken => {\n  subscribers.map(cb => cb(newAccessToken));\n};\nconst subscribeTokenRefresh = cb => {\n  subscribers.push(cb);\n};\naxiosInstance.interceptors.response.use(res => res, async err => {\n  const originalConfig = err.config;\n  if (originalConfig.url !== apiConfig.account.loginBasic.baseURL && err.response) {\n    // Access Token was expired\n    if (err.response?.status === 401 && !originalConfig._retry) {\n      // const handleExpireAll = () => {\n      //     removeCacheToken();\n      //     window.location.reload();\n      // };\n\n      // if (!getCacheRefreshToken()) {\n      //     handleExpireAll();\n      // }\n\n      originalConfig._retry = true;\n      // if (!isRefreshing) {\n      //     isRefreshing = true;\n      //     const email = getCacheUserEmail();\n      //     axiosInstance\n      //         .post(apiConfig.account.refreshToken.baseURL, {\n      //             refreshToken: getCacheRefreshToken(),\n      //             email,\n      //         })\n      //         .then((rs) => {\n      //             const { accessToken, refreshToken } = rs.data.data;\n      //             setCacheToken(accessToken, refreshToken);\n      //             isRefreshing = false;\n      //             onRefreshed(accessToken);\n      //             subscribers = [];\n      //         })\n      //         .catch((_error) => {\n      //             handleExpireAll();\n      //             return Promise.reject(_error);\n      //         });\n      // }\n\n      return new Promise(resolve => {\n        subscribeTokenRefresh(newAccessToken => {\n          originalConfig.headers.Authorization = `Bearer ${newAccessToken}`;\n          return resolve(axiosInstance(originalConfig));\n        });\n      });\n    }\n  }\n  return Promise.reject(err);\n});\nconst sendRequest = (options, payload, cancelToken) => {\n  const {\n    params = {},\n    pathParams = {},\n    data = {}\n  } = payload;\n  let {\n    method,\n    baseURL,\n    headers,\n    ignoreAuth,\n    authorization\n  } = options;\n  const userAccessToken = getCacheAccessToken();\n  if (userAccessToken) {\n    const currentTimestamp = Math.floor(Date.now() / 1000);\n    const decodeAccessToken = jwtDecode(userAccessToken);\n    if (decodeAccessToken?.exp < currentTimestamp) {\n      removeCacheToken();\n    }\n  }\n  delete options.headers[storageKeys.TENANT_HEADER];\n  const tenantId = getData(storageKeys.TENANT_HEADER);\n  if (options && options.isRequiredTenantId && !options.isUpload) {\n    headers[storageKeys.TENANT_HEADER] = tenantId;\n    if (!options.isLogin) baseURL = baseURL.replace(apiTenantUrl, `${getData(storageKeys.TENANT_API_URL)}/`);\n  }\n  if (!ignoreAuth && userAccessToken) {\n    headers.Authorization = `Bearer ${userAccessToken}`;\n  }\n  if (authorization) {\n    headers.Authorization = authorization;\n  }\n\n  // update path params\n  for (let key of Object.keys(pathParams)) {\n    const keyCompare = `:${key}`;\n    if (baseURL.indexOf(keyCompare) !== -1) {\n      baseURL = baseURL.replace(keyCompare, pathParams[key]);\n    }\n  }\n\n  // handle multipart\n  if (options.headers['Content-Type'] === 'multipart/form-data') {\n    let formData = new FormData();\n    Object.keys(data).map(item => {\n      formData.append(item, data[item]);\n    });\n    return axios.post(options.path, formData, {\n      headers: {\n        Authorization: headers.Authorization,\n        'Content-type': 'multipart/form-data',\n        [storageKeys.TENANT_HEADER]: tenantId\n      }\n    }).then(res => {\n      return {\n        data: res.data\n      };\n    }).catch(err => {\n      console.log(err);\n    });\n  }\n  // ...\n  return axiosInstance.request({\n    method,\n    baseURL,\n    headers,\n    params,\n    data,\n    cancelToken\n  });\n};\nexport { sendRequest };","map":{"version":3,"names":["apiTenantUrl","storageKeys","apiConfig","getData","removeItem","axios","getCacheAccessToken","getCacheUserEmail","getCacheRefreshToken","removeCacheToken","setCacheToken","jwtDecode","axiosInstance","create","isRefreshing","subscribers","onRefreshed","newAccessToken","map","cb","subscribeTokenRefresh","push","interceptors","response","use","res","err","originalConfig","config","url","account","loginBasic","baseURL","status","_retry","Promise","resolve","headers","Authorization","reject","sendRequest","options","payload","cancelToken","params","pathParams","data","method","ignoreAuth","authorization","userAccessToken","currentTimestamp","Math","floor","Date","now","decodeAccessToken","exp","TENANT_HEADER","tenantId","isRequiredTenantId","isUpload","isLogin","replace","TENANT_API_URL","key","Object","keys","keyCompare","indexOf","formData","FormData","item","append","post","path","then","catch","console","log","request"],"sources":["C:/Users/PC/Downloads/elms-cms/elms-cms/source/src/services/api.js"],"sourcesContent":["import { apiTenantUrl, storageKeys } from '@constants';\r\nimport apiConfig from '@constants/apiConfig';\r\nimport { getData, removeItem } from '@utils/localStorage';\r\nimport axios from 'axios';\r\nimport {\r\n    getCacheAccessToken,\r\n    getCacheUserEmail,\r\n    getCacheRefreshToken,\r\n    removeCacheToken,\r\n    setCacheToken,\r\n} from './userService';\r\nimport jwtDecode from 'jwt-decode';\r\n// Handle refresh token\r\nconst axiosInstance = axios.create();\r\nlet isRefreshing = false;\r\nlet subscribers = [];\r\n\r\nconst onRefreshed = (newAccessToken) => {\r\n    subscribers.map((cb) => cb(newAccessToken));\r\n};\r\n\r\nconst subscribeTokenRefresh = (cb) => {\r\n    subscribers.push(cb);\r\n};\r\n\r\naxiosInstance.interceptors.response.use(\r\n    (res) => res,\r\n    async (err) => {\r\n        const originalConfig = err.config;\r\n\r\n        if (originalConfig.url !== apiConfig.account.loginBasic.baseURL && err.response) {\r\n            // Access Token was expired\r\n            if (err.response?.status === 401 && !originalConfig._retry) {\r\n                // const handleExpireAll = () => {\r\n                //     removeCacheToken();\r\n                //     window.location.reload();\r\n                // };\r\n\r\n                // if (!getCacheRefreshToken()) {\r\n                //     handleExpireAll();\r\n                // }\r\n\r\n                originalConfig._retry = true;\r\n                // if (!isRefreshing) {\r\n                //     isRefreshing = true;\r\n                //     const email = getCacheUserEmail();\r\n                //     axiosInstance\r\n                //         .post(apiConfig.account.refreshToken.baseURL, {\r\n                //             refreshToken: getCacheRefreshToken(),\r\n                //             email,\r\n                //         })\r\n                //         .then((rs) => {\r\n                //             const { accessToken, refreshToken } = rs.data.data;\r\n                //             setCacheToken(accessToken, refreshToken);\r\n                //             isRefreshing = false;\r\n                //             onRefreshed(accessToken);\r\n                //             subscribers = [];\r\n                //         })\r\n                //         .catch((_error) => {\r\n                //             handleExpireAll();\r\n                //             return Promise.reject(_error);\r\n                //         });\r\n                // }\r\n\r\n                return new Promise((resolve) => {\r\n                    subscribeTokenRefresh((newAccessToken) => {\r\n                        originalConfig.headers.Authorization = `Bearer ${newAccessToken}`;\r\n                        return resolve(axiosInstance(originalConfig));\r\n                    });\r\n                });\r\n            }\r\n        }\r\n        return Promise.reject(err);\r\n    },\r\n);\r\n\r\nconst sendRequest = (options, payload, cancelToken) => {\r\n    const { params = {}, pathParams = {}, data = {} } = payload;\r\n    let { method, baseURL, headers, ignoreAuth, authorization } = options;\r\n\r\n    const userAccessToken = getCacheAccessToken();\r\n    if (userAccessToken) {\r\n        const currentTimestamp = Math.floor(Date.now() / 1000);\r\n        const decodeAccessToken = jwtDecode(userAccessToken);\r\n        if (decodeAccessToken?.exp < currentTimestamp) {\r\n            removeCacheToken();\r\n        }\r\n    }\r\n\r\n    delete options.headers[storageKeys.TENANT_HEADER];\r\n    const tenantId = getData(storageKeys.TENANT_HEADER);\r\n    if (options && options.isRequiredTenantId && !options.isUpload) {\r\n        headers[storageKeys.TENANT_HEADER] = tenantId;\r\n        if (!options.isLogin) baseURL = baseURL.replace(apiTenantUrl, `${getData(storageKeys.TENANT_API_URL)}/`);\r\n    }\r\n    if (!ignoreAuth && userAccessToken) {\r\n        headers.Authorization = `Bearer ${userAccessToken}`;\r\n    }\r\n\r\n    if (authorization) {\r\n        headers.Authorization = authorization;\r\n    }\r\n\r\n    // update path params\r\n    for (let key of Object.keys(pathParams)) {\r\n        const keyCompare = `:${key}`;\r\n        if (baseURL.indexOf(keyCompare) !== -1) {\r\n            baseURL = baseURL.replace(keyCompare, pathParams[key]);\r\n        }\r\n    }\r\n\r\n    // handle multipart\r\n    if (options.headers['Content-Type'] === 'multipart/form-data') {\r\n        let formData = new FormData();\r\n        Object.keys(data).map((item) => {\r\n            formData.append(item, data[item]);\r\n        });\r\n\r\n        return axios\r\n            .post(options.path, formData, {\r\n                headers: {\r\n                    Authorization: headers.Authorization,\r\n                    'Content-type': 'multipart/form-data',\r\n                    [storageKeys.TENANT_HEADER]: tenantId,\r\n                },\r\n            })\r\n            .then((res) => {\r\n                return { data: res.data };\r\n            })\r\n            .catch((err) => {\r\n                console.log(err);\r\n            });\r\n    }\r\n    // ...\r\n    return axiosInstance.request({\r\n        method,\r\n        baseURL,\r\n        headers,\r\n        params,\r\n        data,\r\n        cancelToken,\r\n    });\r\n};\r\n\r\nexport { sendRequest };\r\n"],"mappings":"AAAA,SAASA,YAAY,EAAEC,WAAW,QAAQ,YAAY;AACtD,OAAOC,SAAS,MAAM,sBAAsB;AAC5C,SAASC,OAAO,EAAEC,UAAU,QAAQ,qBAAqB;AACzD,OAAOC,KAAK,MAAM,OAAO;AACzB,SACIC,mBAAmB,EACnBC,iBAAiB,EACjBC,oBAAoB,EACpBC,gBAAgB,EAChBC,aAAa,QACV,eAAe;AACtB,OAAOC,SAAS,MAAM,YAAY;AAClC;AACA,MAAMC,aAAa,GAAGP,KAAK,CAACQ,MAAM,CAAC,CAAC;AACpC,IAAIC,YAAY,GAAG,KAAK;AACxB,IAAIC,WAAW,GAAG,EAAE;AAEpB,MAAMC,WAAW,GAAIC,cAAc,IAAK;EACpCF,WAAW,CAACG,GAAG,CAAEC,EAAE,IAAKA,EAAE,CAACF,cAAc,CAAC,CAAC;AAC/C,CAAC;AAED,MAAMG,qBAAqB,GAAID,EAAE,IAAK;EAClCJ,WAAW,CAACM,IAAI,CAACF,EAAE,CAAC;AACxB,CAAC;AAEDP,aAAa,CAACU,YAAY,CAACC,QAAQ,CAACC,GAAG,CAClCC,GAAG,IAAKA,GAAG,EACZ,MAAOC,GAAG,IAAK;EACX,MAAMC,cAAc,GAAGD,GAAG,CAACE,MAAM;EAEjC,IAAID,cAAc,CAACE,GAAG,KAAK3B,SAAS,CAAC4B,OAAO,CAACC,UAAU,CAACC,OAAO,IAAIN,GAAG,CAACH,QAAQ,EAAE;IAC7E;IACA,IAAIG,GAAG,CAACH,QAAQ,EAAEU,MAAM,KAAK,GAAG,IAAI,CAACN,cAAc,CAACO,MAAM,EAAE;MACxD;MACA;MACA;MACA;;MAEA;MACA;MACA;;MAEAP,cAAc,CAACO,MAAM,GAAG,IAAI;MAC5B;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;MAEA,OAAO,IAAIC,OAAO,CAAEC,OAAO,IAAK;QAC5BhB,qBAAqB,CAAEH,cAAc,IAAK;UACtCU,cAAc,CAACU,OAAO,CAACC,aAAa,GAAI,UAASrB,cAAe,EAAC;UACjE,OAAOmB,OAAO,CAACxB,aAAa,CAACe,cAAc,CAAC,CAAC;QACjD,CAAC,CAAC;MACN,CAAC,CAAC;IACN;EACJ;EACA,OAAOQ,OAAO,CAACI,MAAM,CAACb,GAAG,CAAC;AAC9B,CACJ,CAAC;AAED,MAAMc,WAAW,GAAGA,CAACC,OAAO,EAAEC,OAAO,EAAEC,WAAW,KAAK;EACnD,MAAM;IAAEC,MAAM,GAAG,CAAC,CAAC;IAAEC,UAAU,GAAG,CAAC,CAAC;IAAEC,IAAI,GAAG,CAAC;EAAE,CAAC,GAAGJ,OAAO;EAC3D,IAAI;IAAEK,MAAM;IAAEf,OAAO;IAAEK,OAAO;IAAEW,UAAU;IAAEC;EAAc,CAAC,GAAGR,OAAO;EAErE,MAAMS,eAAe,GAAG5C,mBAAmB,CAAC,CAAC;EAC7C,IAAI4C,eAAe,EAAE;IACjB,MAAMC,gBAAgB,GAAGC,IAAI,CAACC,KAAK,CAACC,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC;IACtD,MAAMC,iBAAiB,GAAG7C,SAAS,CAACuC,eAAe,CAAC;IACpD,IAAIM,iBAAiB,EAAEC,GAAG,GAAGN,gBAAgB,EAAE;MAC3C1C,gBAAgB,CAAC,CAAC;IACtB;EACJ;EAEA,OAAOgC,OAAO,CAACJ,OAAO,CAACpC,WAAW,CAACyD,aAAa,CAAC;EACjD,MAAMC,QAAQ,GAAGxD,OAAO,CAACF,WAAW,CAACyD,aAAa,CAAC;EACnD,IAAIjB,OAAO,IAAIA,OAAO,CAACmB,kBAAkB,IAAI,CAACnB,OAAO,CAACoB,QAAQ,EAAE;IAC5DxB,OAAO,CAACpC,WAAW,CAACyD,aAAa,CAAC,GAAGC,QAAQ;IAC7C,IAAI,CAAClB,OAAO,CAACqB,OAAO,EAAE9B,OAAO,GAAGA,OAAO,CAAC+B,OAAO,CAAC/D,YAAY,EAAG,GAAEG,OAAO,CAACF,WAAW,CAAC+D,cAAc,CAAE,GAAE,CAAC;EAC5G;EACA,IAAI,CAAChB,UAAU,IAAIE,eAAe,EAAE;IAChCb,OAAO,CAACC,aAAa,GAAI,UAASY,eAAgB,EAAC;EACvD;EAEA,IAAID,aAAa,EAAE;IACfZ,OAAO,CAACC,aAAa,GAAGW,aAAa;EACzC;;EAEA;EACA,KAAK,IAAIgB,GAAG,IAAIC,MAAM,CAACC,IAAI,CAACtB,UAAU,CAAC,EAAE;IACrC,MAAMuB,UAAU,GAAI,IAAGH,GAAI,EAAC;IAC5B,IAAIjC,OAAO,CAACqC,OAAO,CAACD,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE;MACpCpC,OAAO,GAAGA,OAAO,CAAC+B,OAAO,CAACK,UAAU,EAAEvB,UAAU,CAACoB,GAAG,CAAC,CAAC;IAC1D;EACJ;;EAEA;EACA,IAAIxB,OAAO,CAACJ,OAAO,CAAC,cAAc,CAAC,KAAK,qBAAqB,EAAE;IAC3D,IAAIiC,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;IAC7BL,MAAM,CAACC,IAAI,CAACrB,IAAI,CAAC,CAAC5B,GAAG,CAAEsD,IAAI,IAAK;MAC5BF,QAAQ,CAACG,MAAM,CAACD,IAAI,EAAE1B,IAAI,CAAC0B,IAAI,CAAC,CAAC;IACrC,CAAC,CAAC;IAEF,OAAOnE,KAAK,CACPqE,IAAI,CAACjC,OAAO,CAACkC,IAAI,EAAEL,QAAQ,EAAE;MAC1BjC,OAAO,EAAE;QACLC,aAAa,EAAED,OAAO,CAACC,aAAa;QACpC,cAAc,EAAE,qBAAqB;QACrC,CAACrC,WAAW,CAACyD,aAAa,GAAGC;MACjC;IACJ,CAAC,CAAC,CACDiB,IAAI,CAAEnD,GAAG,IAAK;MACX,OAAO;QAAEqB,IAAI,EAAErB,GAAG,CAACqB;MAAK,CAAC;IAC7B,CAAC,CAAC,CACD+B,KAAK,CAAEnD,GAAG,IAAK;MACZoD,OAAO,CAACC,GAAG,CAACrD,GAAG,CAAC;IACpB,CAAC,CAAC;EACV;EACA;EACA,OAAOd,aAAa,CAACoE,OAAO,CAAC;IACzBjC,MAAM;IACNf,OAAO;IACPK,OAAO;IACPO,MAAM;IACNE,IAAI;IACJH;EACJ,CAAC,CAAC;AACN,CAAC;AAED,SAASH,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}