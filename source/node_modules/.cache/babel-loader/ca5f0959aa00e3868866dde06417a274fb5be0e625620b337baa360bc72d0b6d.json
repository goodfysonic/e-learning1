{"ast":null,"code":"import { compare } from './compare';\nimport { compareSegments, validateAndParse } from './utils';\n/**\n * Match [npm semver](https://docs.npmjs.com/cli/v6/using-npm/semver) version range.\n *\n * @param version Version number to match\n * @param range Range pattern for version\n * @returns `true` if the version number is within the range, `false` otherwise.\n *\n * @example\n * ```\n * satisfies('1.1.0', '^1.0.0'); // return true\n * satisfies('1.1.0', '~1.0.0'); // return false\n * ```\n */\nexport const satisfies = (version, range) => {\n  // clean input\n  range = range.replace(/([><=]+)\\s+/g, '$1');\n  // handle multiple comparators\n  if (range.includes('||')) {\n    return range.split('||').some(r => satisfies(version, r));\n  } else if (range.includes(' - ')) {\n    const [a, b] = range.split(' - ', 2);\n    return satisfies(version, `>=${a} <=${b}`);\n  } else if (range.includes(' ')) {\n    return range.trim().replace(/\\s{2,}/g, ' ').split(' ').every(r => satisfies(version, r));\n  }\n  // if no range operator then \"=\"\n  const m = range.match(/^([<>=~^]+)/);\n  const op = m ? m[1] : '=';\n  // if gt/lt/eq then operator compare\n  if (op !== '^' && op !== '~') return compare(version, range, op);\n  // else range of either \"~\" or \"^\" is assumed\n  const [v1, v2, v3,, vp] = validateAndParse(version);\n  const [r1, r2, r3,, rp] = validateAndParse(range);\n  const v = [v1, v2, v3];\n  const r = [r1, r2 !== null && r2 !== void 0 ? r2 : 'x', r3 !== null && r3 !== void 0 ? r3 : 'x'];\n  // validate pre-release\n  if (rp) {\n    if (!vp) return false;\n    if (compareSegments(v, r) !== 0) return false;\n    if (compareSegments(vp.split('.'), rp.split('.')) === -1) return false;\n  }\n  // first non-zero number\n  const nonZero = r.findIndex(v => v !== '0') + 1;\n  // pointer to where segments can be >=\n  const i = op === '~' ? 2 : nonZero > 1 ? nonZero : 1;\n  // before pointer must be equal\n  if (compareSegments(v.slice(0, i), r.slice(0, i)) !== 0) return false;\n  // after pointer must be >=\n  if (compareSegments(v.slice(i), r.slice(i)) === -1) return false;\n  return true;\n};","map":{"version":3,"names":["compare","compareSegments","validateAndParse","satisfies","version","range","replace","includes","split","some","r","a","b","trim","every","m","match","op","v1","v2","v3","vp","r1","r2","r3","rp","v","nonZero","findIndex","i","slice"],"sources":["C:\\Users\\PC\\Downloads\\elms-cms\\elms-cms\\source\\node_modules\\compare-versions\\src\\satisfies.ts"],"sourcesContent":["import { compare } from './compare';\nimport { CompareOperator, compareSegments, validateAndParse } from './utils';\n\n/**\n * Match [npm semver](https://docs.npmjs.com/cli/v6/using-npm/semver) version range.\n *\n * @param version Version number to match\n * @param range Range pattern for version\n * @returns `true` if the version number is within the range, `false` otherwise.\n *\n * @example\n * ```\n * satisfies('1.1.0', '^1.0.0'); // return true\n * satisfies('1.1.0', '~1.0.0'); // return false\n * ```\n */\nexport const satisfies = (version: string, range: string): boolean => {\n  // clean input\n  range = range.replace(/([><=]+)\\s+/g, '$1');\n\n  // handle multiple comparators\n  if (range.includes('||')) {\n    return range.split('||').some((r) => satisfies(version, r));\n  } else if (range.includes(' - ')) {\n    const [a, b] = range.split(' - ', 2);\n    return satisfies(version, `>=${a} <=${b}`);\n  } else if (range.includes(' ')) {\n    return range\n      .trim()\n      .replace(/\\s{2,}/g, ' ')\n      .split(' ')\n      .every((r) => satisfies(version, r));\n  }\n\n  // if no range operator then \"=\"\n  const m = range.match(/^([<>=~^]+)/);\n  const op = m ? m[1] : '=';\n\n  // if gt/lt/eq then operator compare\n  if (op !== '^' && op !== '~')\n    return compare(version, range, op as CompareOperator);\n\n  // else range of either \"~\" or \"^\" is assumed\n  const [v1, v2, v3, , vp] = validateAndParse(version);\n  const [r1, r2, r3, , rp] = validateAndParse(range);\n  const v = [v1, v2, v3];\n  const r = [r1, r2 ?? 'x', r3 ?? 'x'];\n\n  // validate pre-release\n  if (rp) {\n    if (!vp) return false;\n    if (compareSegments(v, r) !== 0) return false;\n    if (compareSegments(vp.split('.'), rp.split('.')) === -1) return false;\n  }\n\n  // first non-zero number\n  const nonZero = r.findIndex((v) => v !== '0') + 1;\n\n  // pointer to where segments can be >=\n  const i = op === '~' ? 2 : nonZero > 1 ? nonZero : 1;\n\n  // before pointer must be equal\n  if (compareSegments(v.slice(0, i), r.slice(0, i)) !== 0) return false;\n\n  // after pointer must be >=\n  if (compareSegments(v.slice(i), r.slice(i)) === -1) return false;\n\n  return true;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}