"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addIdToDefineMessage = addIdToDefineMessage;

var _path = require("path");

var t = _interopRequireWildcard(require("@babel/types"));

var _utils = require("../utils");

var _isImportLocalName = require("../utils/isImportLocalName");

var _getPrefix = require("../utils/getPrefix");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import blog from 'babel-log'
const getId = (path, prefix, separator) => {
  let name;

  if (path.isStringLiteral()) {
    name = path.node.value;
  } else if (path.isIdentifier()) {
    name = path.node.name;
  }

  if (!name) {
    throw new Error(`requires Object key or string literal`);
  }

  return (0, _utils.dotPath)((0, _path.join)(prefix, name), separator);
};

const getLeadingComment = prop => {
  const commentNodes = prop.node.leadingComments;
  return commentNodes ? commentNodes.map(node => node.value.trim()).join('\n') : null;
}; // eslint-disable-next-line max-lines-per-function


const replaceProperties = (properties, state, exportName) => {
  const prefix = (0, _getPrefix.getPrefix)(state, exportName);
  const {
    opts: {
      separator
    }
  } = state;

  for (const prop of properties) {
    const objectValuePath = prop.get('value');
    const objectKeyPath = prop.get('key');

    if (Array.isArray(objectKeyPath)) {
      return;
    }

    const messageDescriptorProperties = []; // { defaultMessage: 'hello', description: 'this is hello' }

    if (objectValuePath.isObjectExpression()) {
      const objProps = objectValuePath.get('properties'); // { id: 'already has id', defaultMessage: 'hello' }

      const isNotHaveId = objProps.every(v => {
        const keyPath = v.get('key');
        return !Array.isArray(keyPath) && keyPath.node.name !== 'id';
      });

      if (isNotHaveId) {
        const id = getId(objectKeyPath, prefix, separator);
        messageDescriptorProperties.push((0, _utils.objectProperty)('id', id));
      }

      messageDescriptorProperties.push(...objProps.map(v => v.node));
    } else if (objectValuePath.isStringLiteral() || objectValuePath.isTemplateLiteral()) {
      // 'hello' or `hello ${user}`
      const id = getId(objectKeyPath, prefix, separator);
      messageDescriptorProperties.push((0, _utils.objectProperty)('id', id), (0, _utils.objectProperty)('defaultMessage', objectValuePath.node));
    } else {
      const evaluated = prop.get('value').evaluate();

      if (evaluated.confident && typeof evaluated.value === 'string') {
        const id = (0, _utils.dotPath)((0, _path.join)(prefix, evaluated.value), separator);
        messageDescriptorProperties.push((0, _utils.objectProperty)('id', id), (0, _utils.objectProperty)('defaultMessage', evaluated.value));
      }
    }

    const {
      extractComments = true
    } = state.opts;

    if (extractComments) {
      const hasDescription = messageDescriptorProperties.find(v => v.key.name === 'description');

      if (!hasDescription) {
        const description = getLeadingComment(prop);

        if (description) {
          messageDescriptorProperties.push((0, _utils.objectProperty)('description', description));
        }
      }
    }

    objectValuePath.replaceWith(t.objectExpression(messageDescriptorProperties));
  }
};

const getExportName = (path, includeExportName) => {
  const namedExport = path.findParent(v => v.isExportNamedDeclaration());
  const defaultExport = path.findParent(v => v.isExportDefaultDeclaration());

  if (includeExportName && namedExport) {
    const idPath = namedExport.get('declaration.declarations.0.id');
    return idPath.node.name;
  }

  if (includeExportName === 'all' && defaultExport) {
    return 'default';
  }

  return null;
};

const isDefineMessagesCall = (path, state) => {
  /**
  Path "Identifier"
  name: "defineMessages"
  */
  const callee = path.get('callee');
  return callee.isIdentifier() && (0, _isImportLocalName.isImportLocalName)(callee.node.name, ['defineMessages'], state);
};

function addIdToDefineMessage(path, state) {
  if (!isDefineMessagesCall(path, state)) {
    return;
  }

  if (!path.get('arguments.0')) {
    return;
  }

  const argPath = path.get('arguments.0');
  const properties = (0, _utils.getObjectProperties)(argPath);

  if (!properties) {
    return;
  }

  const exportName = getExportName(path, state.opts.includeExportName || false);
  replaceProperties(properties, state, exportName);
}